#!/usr/bin/env python3

import os
import subprocess
import tempfile
import signal
import time
from typing import Dict
from ctypes import c_uint32, c_uint64, c_char, Structure

class StackFrameInfo(Structure):
    _fields_ = [
        ("filename", c_char * 100),
        ("funcname", c_char * 100),
    ]

class StackTrace(Structure):
    _fields_ = [
        ("pid", c_uint32),
        ("num_frames", c_uint32),
        ("timestamp_ns", c_uint64),
        ("frames", StackFrameInfo * 20),
    ]

class BPFProfiler:
    def __init__(self):
        self.process = None
        self.output_file = None
        self.pid = None
        self.executable_path = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), 
            "src", 
            "pyprofiler"
        )
        
        if not os.path.exists(self.executable_path):
            raise FileNotFoundError(
                f"pyprofiler executable not found at {self.executable_path}. "
                "Please build it first by running 'make' in the src directory."
            )
        
        self.bpf = {"do_sample": True}
        self._profile_data = []
    
    def attach(self, pid: int, sample_rate: int = 99):
        """Attach the profiler to a process"""
        if self.process is not None:
            raise RuntimeError("Profiler is already attached to a process")
        
        self.pid = pid
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as f:
            self.output_file = f.name
        
        cmd = [
            'sudo', '-S',
            self.executable_path,
            '-o', self.output_file,
            '-f', '1',
            '-r', str(sample_rate),
            str(pid)
        ]
        
        self.process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        self.process.stdin.write('123456\n')
        self.process.stdin.flush()
        
        time.sleep(0.5)
        
        if self.process.poll() is not None:
            _, stderr = self.process.communicate()
            raise RuntimeError(f"Failed to start profiler: {stderr}")
    
    def detach(self):
        """Detach the profiler from the process"""
        if self.process is None:
            return
        
        if self.process.poll() is None:
            self.process.send_signal(signal.SIGTERM)
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()
                self.process.wait()
        
        # Close the file handles to avoid ResourceWarning
        if self.process.stdin:
            self.process.stdin.close()
        if self.process.stdout:
            self.process.stdout.close()
        if self.process.stderr:
            self.process.stderr.close()
        
        if self.output_file and os.path.exists(self.output_file):
            self._parse_output_file()
            os.unlink(self.output_file)
        
        self.process = None
        self.output_file = None
        self.pid = None
    
    def _parse_output_file(self):
        """Parse the output file generated by pyprofiler"""
        if not self.output_file or not os.path.exists(self.output_file):
            return
        
        self._profile_data = []
        
        try:
            with open(self.output_file, 'r') as f:
                lines = f.readlines()
            
            for line in lines:
                line = line.strip()
                if not line or line.startswith('#') or line.startswith('FORMAT') or line.startswith('METADATA') or line.startswith('HEADER'):
                    continue
                
                if line.startswith('EVENT|'):
                    parts = line.split('|')
                    if len(parts) >= 4:
                        timestamp = int(parts[1])
                        pid = int(parts[2])
                        frame_count = int(parts[3])
                        
                        frames = []
                        for i in range(4, min(4 + frame_count, len(parts))):
                            if ':' in parts[i]:
                                filename, funcname = parts[i].split(':', 1)
                                frames.append({
                                    'filename': filename,
                                    'funcname': funcname
                                })
                        
                        self._profile_data.append({
                            'timestamp': timestamp,
                            'pid': pid,
                            'frames': frames
                        })
        except Exception as e:
            print(f"Error parsing output file: {e}")
    
    def get_profile(self) -> Dict:
        """Get the collected profile data"""
        return {
            "samples": self._profile_data
        }
    
    def __del__(self):
        """Cleanup when the object is destroyed"""
        if self.process is not None:
            self.detach()